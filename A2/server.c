/* 
Name: Mi Su
Student Id: W1611208

Description: a program that enables client sending packets to server for requesting access to celluar
network. The server will verify the client's identification by checking the txt database information.
If the server can't find client's subscriber num in the database, or if subscriber num found but tech
type mismatch, the server will respond by sending Not Exit message; if subscriber not paid, the server
will respond by sending Not Paid message; otherwise, the server will send a permit to access message.

Assumption: 1. the client only resend packet when time out happens(receiving no response within 3 seconds),
the client can resend up to 3 times for time out situation, if still no response from server, an error
message will be generated by the client. 2. Assume server response packet tech type is the same as client
sending packet, if the subscriber number not found, the response packet tech type will be set as 0x00
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <poll.h>
#include <stdbool.h>

#define PACKET_NUM 5 //number of packet to send is 5
#define SP_ID 0xFFFF //start of packet ID
#define EP_ID 0xFFFF //end of packet ID
#define CLIENT_ID 0x48 //client ID (the max is 0xFF)
#define MAX_LENGTH 0xFF // max length for payload

#define ACC_PER 0xFFF8 //define different types for packets
#define NOT_PAID 0xFFF9
#define NOT_EXIST 0xFFFA
#define ACC_OK 0xFFFB

#define G2 0x02 //define different types of technologies
#define G3 0x03
#define G4 0x04
#define G5 0x05

//define the structure for data packet
typedef struct dataPacket {
    short start_id;
    char client_id;
    short type;
    char segment_num;
    char length;
    char tech;
    unsigned long sub_num; //subscriber phone number
    short end_id;
}dataPacket;

//define a node stucture for storing each line content in text file
typedef struct node {
    unsigned long sub_num;
    char tech;
    char paid;
    struct node *next;
}node;

//linked list head, tail initialize
node *head = NULL;
node *tail = NULL;

//function for inserting node into the linkedlist
void insert(unsigned long sub_num, char tech, char paid) {
    node *record = (node *)malloc(sizeof(node));//dynamically creat a node
    //node *r;???
    //populate node attribute
    record->sub_num = sub_num;
    record->tech = tech;
    record->paid = paid;

    //insert node
    if (head == NULL) {//if it is first node
        head = record;
        tail = record;
        tail ->next = NULL;
    } else { //if it is not first node
        tail->next = record;
        tail = record;
        tail->next = NULL;
    }

}

//a function for reading the txt file and store related content in linkedlist
int readfile(char *file) {
    FILE *fp;
    unsigned long sub_num;
    unsigned int tech;
    unsigned int paid;

    fp = fopen(file, "r");
    if (fp == NULL) {
        printf("File open error!\n");
        return -1;
    }
    while((fscanf(fp, "%lu %x %x", &sub_num, &tech, &paid) > 0)) {//scan all records
        insert(sub_num, (char)tech, (char)paid);//insert records to linked list
    }
    fclose(fp);
    return 1;
}

//traverse the subscriber number in linked list and return the node if found
node *traverse(unsigned long num) {
    node *n = head;
    while (n != NULL) {
        if (n->sub_num == num) {
            return n;
        } else {
            n = n->next;
        }
    }
    return NULL;//return NULL if can't find sub_num
}

int main(int argc, char *argv[]) {
    if (argc < 2) { //check there is port number provided or not
        fprintf(stderr,"ERROR, no port provided\n");
        exit(1);
    }
    int port = atoi(argv[1]);

    int sockfd;
    dataPacket data;
    struct sockaddr_in server_addr, client_addr; //declare server address, client address
    socklen_t addr_size = sizeof(client_addr); //address size

    sockfd = socket(AF_INET, SOCK_DGRAM, 0); //create a socket at server side
    if (sockfd < 0) { 
        perror("ERROR opening socket");
        exit(1);
    }

    //set up server address    
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(port);

    //bind the address to socket
    if (bind(sockfd, (struct sockaddr *) &server_addr,sizeof(server_addr)) < 0) {
        perror("ERROR on binding");
        exit(1);
    }
    printf("Done with binding\n");
    printf("Listening on port %d for incoming messages...\n\n", port);

    if (readfile("Verification_Database.txt") != 1) {//read file into linkedlist
        printf("Server: Error reading file\n");
        return -1;
    };
    
    dataPacket res;//declare response packet

    //receive packets one by one from client
    while (true) {
        int recv = recvfrom(sockfd, &data, sizeof(dataPacket), 0, (struct sockaddr *)&client_addr, &addr_size);
        if (recv > 0) {
            printf("Server: Received access request from subscriber %lu \n", data.sub_num);
        } else {
            printf("Server: Error Receive!\n");
        }

        //populate attribte for response packet
        res.start_id = SP_ID;
        res.end_id = EP_ID;
        res.client_id = CLIENT_ID;
        res.segment_num = data.segment_num;
        res.length = data.length;
        res.sub_num = data.sub_num;
        res.tech = data.tech; //assume response packet techology is the same as original packet

        node* result = traverse(data.sub_num);//search for subscribe num in current packet
        if (result == NULL) {//subscriber number not exist
            res.type = NOT_EXIST;
            res.tech = 0x00; //mark tech as 0x00 for subscriber number not found
            printf("Server: Subscriber %lu not found on database\n\n", res.sub_num);
        } else if (result->tech != data.tech) {//subscriber number found but tech mismatch
            res.type = NOT_EXIST;
            printf("Server: Subscriber %lu technology mismatch with database\n\n", res.sub_num);
        } else if (result->paid == 0) {//user exists but not paid
            res.type = NOT_PAID;
            printf("Server: Subscriber %lu has not paid\n\n", res.sub_num);
        } else { //verified user give permission
            res.type = ACC_OK;
            printf("Server: Subscriber %lu permitted to access the network\n\n", res.sub_num);
        }

        //send response packet to client
        sendto(sockfd, &res, sizeof(dataPacket), 0, (struct sockaddr *)&client_addr, addr_size);

    }
    close(sockfd);
    return 0;
}

